# 枚举

>枚举的思想是不断地猜测，从可能的集合中一一尝试，然后在判断题目的条件是否成立。

## 枚举题目解题要点：

- **给出解空间**

	建立简洁的数学模型

	枚举的时候要想清楚：可能的情况是什么？要枚举哪些要素

- **减少枚举的空间**
	
	 枚举的范围是什么？是所有的内容都需要枚举吗？

- **选择适合的枚举顺序**
	
	根据题目判断。比如例题中要求的是最大的符合条件的素数，那自然是从大到小枚举比较合适

## 例题

>一个数组中的数互不相同，求其中和为0的数对的个数。

最简单的方法是全部遍历出来

```C++

// C++ Version
for (int i = 0; i < n; ++i)
  for (int j = 0; j < n; ++j)
    if (a[i] + a[j] == 0) ++ans;
```

以上枚举范围是n*n,我们可以尝试将枚举的范围降低。题目没有要求数对是有序的，答案是有序情况的两倍。对于这种情况，只需要认为要求有顺序之后的答案，最后再乘上2就好了

```c++

// C++ Version
for (int i = 0; i < n; ++i)
  for (int j = 0; j < i; ++j)
    if (a[i] + a[j] == 0) ++ans;
```

现在我们已经将枚举的范围降低到 $(n-1) \div 2 \times n$ ,但是目前为止我们还是双重循环，考虑下能不能只循环一次。如果能找到一种方法直接判断题目要求的那个数是否存在，就可以省掉枚举后一个数的时间.在数据范围允许的情况下，我们使用桶记录遍历过的数。

```c++
// C++ version
bool met[MAXN*2];
memset(met,0,sizeof(met));
for(int i=0;i<n;++i){
    if(met[MAXN-a[i]]) ans+=1;
    met[MAXN+a[i]]=true;
}
```



***

## 练习

**[2811:熄灯问题](http://bailian.openjudge.cn/practice/2811/)**

```
```

