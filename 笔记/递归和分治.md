# 递归和分治

> 递归（英文：recursion），在数学和计算机科学中是指在函数的定义中使用函数自身的方法，在计算机科学中还额外指一种通过重复将问题分解为同类的子问题而解决问题的方法。

> 分治（英文：Divide and Conquer），字面上的解释是“分而治之”，就是把一个复杂的问题分成两个或更多的相同或相似的子问题，知道最后子问题可以简单的直接求解，原问题的解即子问题的解的合并。

## 详细介绍

递归的基本思想是某个函数直接或者间接地调用自身，这样原问题的求解就转换为许多性质相同但是规模更小的子问题。求解只需要关注如何把原问题划分成符合条件的子问题而不需要过分关注这个子问题是如何被解决的。

**递归代码最重要的两个特征：** *结束条件和自我调用。*

```c++
int func(传入数值){
	if(终止条件)return 最小子问题解;
	return func(缩小规模);
}
```



## 为什么要写递归

1. 结构清晰，可读性强。例如分别用不同的方法实现*归并排序*

   ```c++
   //不使用递归版本
   template <typename T>
   void merge_sort(vector<T> a) {
     int n = a.size();
     for (int seg = 1; seg < n; seg = seg + seg)
       for (int start = 0; start < n - seg; start += seg + seg)
         merge(a, start, start + seg - 1, std::min(start + seg + seg - 1, n - 1));
   }
   
   //使用递归版本
   template <typename T>
   void merge_sort(vector<T> a, int front, int end) {
     if (front >= end) return;
     int mid = front + (end - front) / 2;
     merge_sort(a, front, mid);
     merge_sort(a, mid + 1, end);
     merge(a, front, mid, end);
   }
   ```

   

## 递归缺点

递归是利用堆栈来实现的。每当进入一个函数调用，栈就会增加一层栈帧，每次函数返回，栈就会减少一层栈帧。而栈不是无限大的，当递归层数过多时，就会造成栈溢出的后果。

## 递归优化

主要两种优化方式：**搜索优化**和**记忆化搜索**

比较初级的递归实现可能递归次数太多，容易超时。这时需要对递归进行优化。

# 分治算法

分治算法大概流程：**分解->解决->合并**

1. 分解原问题为结构相同的子问题。
2. 分解到某个容易求解的边界之后，进行递归求解。
3. 将子问题的解合并成原问题的解

分治法能解决的问题一般有如下特征：

- 该问题的规模缩小到一定的程度就可以容易地解决。
- 该问题可以分解为若干个规模较小的相同问题，即该问题具有最优子结构性质，利用该问题分解出的子问题的解可以合并为该问题的解。
- 该问题所分解出的各个子问题是相互独立的，即子问题之间不包含公共的子问题。

**注意！如果各种子问题是不独立的，则分治法要重复地解公共的子问题，也就做了许多不必要的工作。此时虽然也能用分治法，但一般用*动态规划* 较好**

## 要点

*递归要点*：**明白一个函数的作用并相信它能完成这个任务，千万不要跳进这个函数里面企图探究更多细节**，否则就会陷入无穷的细节无法自拔。

## 区别

### 递归与枚举的区别

递归和枚举的区别在于：枚举是横向地把问题划分，然后依次求解子问题；而递归是把问题逐级分解，是纵向的拆分。

### 递归与分治的区别

递归是一种编程技巧，一种解决问题的思维方式；分治算法很大程度上是基于递归的，解决更具体问题的算法思想。

# 例题

**437.路径总和III**

>给定一个二叉树，它的每个结点都存放着一个整数值。
>
>找出路径和等于给定数值的路径总数。
>
>路径不需要从根节点开始，也不需要在叶子节点结束，但是路径方向必须是向下的（只能从父节点到子节点）。
>
>二叉树不超过 1000 个节点，且节点数值范围是[-1000000,1000000]的整数。
>
>示例：
>
>```c++
>root = [10,5,-3,3,2,null,11,3,-2,null,1], sum = 8
>
>      10
>     /  \
>    5   -3
>   / \    \
>  3   2   11
> / \   \
>3  -2   1
>
>返回 3。和等于 8 的路径有：
>
>1.  5 -> 3
>2.  5 -> 2 -> 1
>3. -3 -> 11
>```
>
>```c++
>/**
> * 二叉树结点的定义
> * struct TreeNode {
> *     int val;
> *     TreeNode *left;
> *     TreeNode *right;
> *     TreeNode(int x) : val(x), left(NULL), right(NULL) {}
> * };
> */
>```
>
>Answer:
>
>```C++
>int pathSum(TreeNode *root, int sum) {
>  if (root == nullptr) return 0;
>  return count(root, sum) + pathSum(root->left, sum) +
>         pathSum(root->right, sum);
>}
>
>int count(TreeNode *node, int sum) {
>  if (node == nullptr) return 0;
>  return (node->val == sum) + count(node->left, sum - node->val) +
>         count(node->right, sum - node->val);
>}
>```
>
>

