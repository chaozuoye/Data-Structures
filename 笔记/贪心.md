# 贪心

> 贪心算法（英语：greedy algorithm），是用计算机来模拟一个“贪心”的人做出决策的过程。这个人十分贪婪，每一步行动总是按某种指标选取最优的操作。而且他目光短浅，总是只看眼前，并不考虑以后可能造成的影响。

一般使用贪心法时，都要确保自己能证明其正确性。

## 详细介绍

使用范围：**贪心算法在有最优子结构的问题中尤为有效。最优子结构的意思时问题能够分解成子问题来解决，子问题的最优解能递推到最终问题的最优解。**

证明方法：
		1. 反证法：如果交换方案中任意量个元素/相邻的两个元素后，答案不会变得更好，那么可以推定目前的解已经时最优解了。
  		2. 归纳法：先算出边界情况的最优解$F_1$，然后证明对于每个n，$F_{n+1}$ 都可以由$F_n$ 推导出结果。

## 要点

在提高组难度以下的题目中，最常见的贪心有两种

- 我们将 XXX 按照某某顺序排序，然后按某种顺序（例如从小到大）选择。
- 我们每次都取 XXX 中最大/小的东西，并更新 XXX。（有时「XXX 中最大/小的东西」可以优化，比如用优先队列维护）

二者的区别在于一种是离线的，先处理后选择；一种是在线的，边处理边选择。

## 排序解法

用怕徐法常见的情况是输入一个包含几个权值的数组，通过排序然后遍历模拟计算的方法求出最优值。

## 后悔解法

思路是无论当前的选项是否最优都接受，然后进行比较，如果选择之后不是最优了，则反悔，舍弃掉这个选项；否则正式接受，如此反复。

## 区别

与动态规划的区别

贪心算法与动态规划的不同在于它对每个子问题的解决方案都做出选择，不能回退。动态规划则会保存以前的运算结果，并根据以前的结果进行选择，有回退功能。

## 例题

后悔法例题：

> 约翰的工作日从0时刻开始，有$10^9$个单位时间。在任一单位时间，他都可以选择编号1到N的$N(1\leq D_i \leq 10^5)$项工作中的任意一项工作来完成。工作$i$截止时间是$D_i(1\leq D_i \leq 10^9)$，完成后获利是$P_i(1\leq P_i \leq 10^9)$。在给定的工作利润和截止时间下，求约翰能够获得的利润最大为多少。

解题思路：

> 1. 先假设每一项工作都做，将各项工作按截止时间排序后入队；
> 2. 在判断第 项工作做与不做时，若其截至时间符合条件，则将其与队中报酬最小的元素比较，若第 项工作报酬较高（后悔），则 `ans += a[i].p - q.top()`。 用优先队列（小根堆）来维护队首元素最小。

```C++
#include <algorithm>
#include <cmath>
#include <cstdio>
#include <cstring>
#include <iostream>
#include <queue>
using namespace std;

struct f {
  long long d;
  long long x;
} a[100005];

bool cmp(f A, f B) { return A.d < B.d; }

priority_queue<long long, vector<long long>, greater<long long> >
    q;  // 小根堆维护最小值

int main() {
  long long n, i, j;
  cin >> n;
  for (i = 1; i <= n; i++) {
    cin >> a[i].d >> a[i].x;
  }
  sort(a + 1, a + n + 1, cmp);
  long long ans = 0;
  for (i = 1; i <= n; i++) {
    if (a[i].d <= q.size()) {  // 超过截止时间
      if (q.top() < a[i].x) {  // 后悔
        ans += a[i].x - q.top();
        q.pop();
        q.push(a[i].x);
      }
    } else {  // 直接加入队列
      ans += a[i].x;
      q.push(a[i].x);
    }
  }
  cout << ans << endl;
  return 0;
}
```

